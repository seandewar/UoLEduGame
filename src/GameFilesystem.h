#pragma once

#include <string>
#include <memory>
#include <vector>
#include <cassert>
#include <stdexcept>

#include "Types.h"

/**
* The type of exception being thrown
*/
enum class GameFilesystemExceptionType
{
    Other,
    NameIsEmpty,
    NameIsTooBig,
    NameHasInvalidCharacters,
    NameIsTaken
};

/**
* Exception class thrown by classes relating to the virtual fs.
*/
class GameFilesystemException : public std::runtime_error
{
    GameFilesystemExceptionType type_;

public:
	GameFilesystemException(const std::string& msg,
        GameFilesystemExceptionType type = GameFilesystemExceptionType::Other) :
		std::runtime_error(msg),
        type_(type)
	{ }
	
    virtual ~GameFilesystemException() throw()
    { }

    inline GameFilesystemExceptionType GetType() const { return type_; }
};

/**
* The type of node
*/
enum class GameFilesystemNodeType
{
    RootDirectory,
    Directory,
    Device,
    NullDevice,
    FullDevice,
    ZeroDevice,
    RandomDevice,
	OtherFile,
    ExecutableFile,
    ShellScriptFile,
    TextFile,
    ImageFile,
    LibraryFile
};

/**
* A node of the virtual filesystem tree.
*/
class GameFilesystemNode
{
	friend class GameFilesystem;

	std::string name_;
	GameFilesystemNodeType type_;
	GameFilesystemNode* parentNode_;

	RngInt randomId_;

	std::vector<std::unique_ptr<GameFilesystemNode>> childNodes_;

public:
	GameFilesystemNode(const std::string& name, GameFilesystemNodeType type, RngInt randomId);
	~GameFilesystemNode();

	GameFilesystemNode* AddChildNode(std::unique_ptr<GameFilesystemNode>&& node);

	inline GameFilesystemNode* GetChildNode(std::size_t i) 
    { 
        return i < childNodes_.size() ? childNodes_[i].get() : nullptr;
    }

    inline GameFilesystemNode* GetChildNode(const std::string& name)
    {
        for (auto& node : childNodes_) {
            assert(node);
            if (node->GetName() == name) {
                return node.get();
            }
        }

        return nullptr; // child not found with that name
    }

    inline const GameFilesystemNode* GetChildNode(std::size_t i) const
    {
        return i < childNodes_.size() ? childNodes_[i].get() : nullptr;
    }

    inline const GameFilesystemNode* GetChildNode(const std::string& name) const
    {
        for (auto& node : childNodes_) {
            assert(node);
            if (node->GetName() == name) {
                return node.get();
            }
        }

        return nullptr; // child not found with that name
    }

	void SetName(const std::string& name);
	inline std::string GetName() const { return name_; }

	inline GameFilesystemNodeType GetType() const { return type_; }

	inline GameFilesystemNode* GetParent() { return parentNode_; }
	inline const GameFilesystemNode* GetParent() const { return parentNode_; }

    inline bool IsDirectory() const
    { 
        return type_ == GameFilesystemNodeType::RootDirectory || type_ == GameFilesystemNodeType::Directory; 
    }

	inline bool IsRootDirectoryNode() const { return type_ == GameFilesystemNodeType::RootDirectory; }
	inline std::size_t GetChildrenCount() const { return childNodes_.size(); }

	inline RngInt GetRandomIdentifier() const { return randomId_; }
};

/**
* Class representing the virtual filesystem tree generated by the game.
*/
class GameFilesystem
{
	std::unique_ptr<GameFilesystemNode> rootNode_;

public:
    static std::string GetNodePathString(const GameFilesystemNode& node);

	GameFilesystem();
	~GameFilesystem();

    GameFilesystemNode* GetNodeFromPathString(const std::string& path);

	GameFilesystemNode* SetRootNode(std::unique_ptr<GameFilesystemNode>&& node);
	inline GameFilesystemNode* GetRootNode() { return rootNode_.get(); }
};

